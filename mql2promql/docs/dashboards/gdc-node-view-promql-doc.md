# MQL to PromQL Conversion Guide - GDC Node View

This document explains the proposed translations to Prometheus Query Language (PromQL) of the `dashboards/gdc-node-view.json` dashboard and the Testing Results

## `dashboards/gdc-node-view.json`

| Group | Input Query Title | Input Query Type | Source Query | LLM Reasoning | LLM Output Query Type | LLM Output PromQL Query | Comments |
| --- | --- | --- | --- | --- | --- | --- | --- |
| Scorecard | Total Nodes | MQL | `fetch k8s_node \| metric 'kubernetes.io/anthos/node/cpu/total_cores' \| ... \| group_by [], [row_count: row_count()]` | The MQL query counts the number of nodes. The PromQL equivalent uses the `count` function on the same metric. | PromQL | `count(kubernetes_io:anthos_node_cpu_total_cores{monitored_resource="k8s_node",${project_id},${cluster_name}})` | A more standard way to count nodes in PromQL would be `count(kube_node_info)`. |
| Scorecard | Total Cores | MQL | `fetch k8s_node \| metric 'kubernetes.io/anthos/node/cpu/total_cores' \| ... \| group_by [], [aggregate(...)]` | The MQL query sums the total cores across all nodes. This is a direct translation to the `sum` function in PromQL. | PromQL | `sum(kubernetes_io:anthos_node_cpu_total_cores{monitored_resource="k8s_node",${project_id},${cluster_name}})` | |
| Scorecard | Allocatable Cores | MQL | `fetch k8s_node \| metric 'kubernetes.io/anthos/node/cpu/allocatable_cores' \| ... \| group_by [], [aggregate(...)]` | The MQL query sums the allocatable cores across all nodes. This is a direct translation to the `sum` function in PromQL. | PromQL | `sum(kubernetes_io:anthos_node_cpu_allocatable_cores{monitored_resource="k8s_node",${project_id},${cluster_name}})` | |
| Scorecard | Total Memory | MQL | `fetch k8s_node \| metric 'kubernetes.io/anthos/node/memory/total_bytes' \| ... \| group_by [], [aggregate(...)]` | The MQL query sums the total memory across all nodes. This is a direct translation to the `sum` function in PromQL. | PromQL | `sum(kubernetes_io:anthos_node_memory_total_bytes{monitored_resource="k8s_node",${project_id},${cluster_name}})` | |
| Scorecard | Allocatable Memory | MQL | `fetch k8s_node \| metric 'kubernetes.io/anthos/node/memory/allocatable_bytes' \| ... \| group_by [], [aggregate(...)]` | The MQL query sums the allocatable memory across all nodes. This is a direct translation to the `sum` function in PromQL. | PromQL | `sum(kubernetes_io:anthos_node_memory_allocatable_bytes{monitored_resource="k8s_node",${project_id},${cluster_name}})` | |
| CPU and Memory | CPU Usage per Node | MQL | `{...} \| join \| value [scaled_util: val(0) * val(1)]` | The MQL query joins allocatable utilization with allocatable cores and multiplies them. The PromQL equivalent uses `avg_over_time` for both metrics and multiplies the results. | PromQL | `avg_over_time(kubernetes_io:anthos_node_cpu_allocatable_utilization{monitored_resource="k8s_node",${project_id},${cluster_name}}[1m]) * avg_over_time(kubernetes_io:anthos_node_cpu_allocatable_cores{monitored_resource="k8s_node",${project_id},${cluster_name}}[1m])` | |
| CPU and Memory | Memory Usage per Node | MQL | `fetch k8s_node \| metric 'kubernetes.io/anthos/node/memory/used_bytes' \| ... \| group_by [resource.node_name], ...` | The MQL query calculates the mean of used bytes per node. This is translated to `sum by (node_name)` and `avg_over_time` in PromQL. | PromQL | `sum by (node_name) (avg_over_time(kubernetes_io:anthos_node_memory_used_bytes{monitored_resource="k8s_node",${project_id},${cluster_name}}[1m]))` | |
| CPU and Memory | CPU Util % per Node | MQL | `fetch k8s_node \| metric 'kubernetes.io/anthos/node/cpu/allocatable_utilization' \| ... \| scale '%'` | The MQL query calculates the mean of a gauge metric and scales it to a percentage. This is translated to `avg_over_time` and multiplication by 100 in PromQL. | PromQL | `avg_over_time(kubernetes_io:anthos_node_cpu_allocatable_utilization{monitored_resource="k8s_node",${project_id},${cluster_name}}[1m]) * 100` | |
| CPU and Memory | Memory Util % per Node | MQL | `fetch k8s_node \| metric 'kubernetes.io/anthos/node/memory/allocatable_utilization' \| ... \| group_by [resource.node_name], ... \| scale '%'` | Similar to the CPU utilization query, but grouped by node. This is translated to `avg by (node_name)` and `avg_over_time` in PromQL. | PromQL | `avg by (node_name) (avg_over_time(kubernetes_io:anthos_node_memory_allocatable_utilization{monitored_resource="k8s_node",${project_id},${cluster_name}}[1m])) * 100` | |
| Pod and Container Count | Number of Containers per Node | MQL | `... \| group_by [metadata.system.node_name], [row_count()]` | The MQL query counts containers per node. The PromQL equivalent uses `count by (node_name)`. | PromQL | `count by (node_name) (kubernetes_io:anthos_container_cpu_core_usage_time{monitored_resource="k8s_container",${project_id},${cluster_name}})` | |
| Pod and Container Count | Number of Pods per Node | MQL | `... \| group_by [metadata.system.node_name], [row_count()]` | The MQL query counts pods per node. The PromQL equivalent uses `count by (node_name)`. | PromQL | `count by (node_name) (kubernetes_io:anthos_pod_network_received_bytes_count{monitored_resource="k8s_pod",${project_id},${cluster_name}})` | |
| Network Usage per Node | Received bytes per node | MQL | `... \| align rate(1m) \| ...` | The MQL query calculates the rate of received bytes. This is a direct translation to the `rate()` function in PromQL. | PromQL | `sum by (node_name) (rate(kubernetes_io:anthos_node_network_received_bytes_count{monitored_resource="k8s_node",${project_id},${cluster_name},interface=~"enp81s0f.*"}[1m]))` | |
| Network Usage per Node | Send bytes per node | MQL | `... \| align rate(1m) \| ...` | Similar to the received bytes query, this calculates the rate of sent bytes. | PromQL | `sum by (node_name) (rate(kubernetes_io:anthos_node_network_sent_bytes_count{monitored_resource="k8s_node",${project_id},${cluster_name},interface=~"enp81s0f.*"}[1m]))` | |
| Storage Usage per Node | Free Robin Disk Space % per Node | MQL | `{...} \| join \| value [v_0: 1 - div(t_0.value_robin_disk_rawused_sum, t_1.value_robin_disk_size_mean)]` | The MQL query calculates the free disk space percentage. The PromQL query performs the same calculation using subtraction and division. | PromQL | `1 - (sum by (node_name) (robin_disk_nslices{${project_id},${cluster_name}}) * 1073741824 / sum by (node_name) (robin_disk_size{${project_id},${cluster_name}}))` | |
| Storage Usage per Node | Free Robin Disk Space % per Node | MQL | `{...} \| join \| value [Disk_Free: cast_units(t_1.value_robin_disk_size_mean - t_0.value_robin_disk_rawused_sum, 'By')]` | The MQL query calculates the free disk space in bytes. The PromQL query performs the same calculation using subtraction. | PromQL | `sum by (node_name) (robin_disk_size{${project_id},${cluster_name}}) - sum by (node_name) (robin_disk_nslices{${project_id},${cluster_name}}) * 1073741824` | |

