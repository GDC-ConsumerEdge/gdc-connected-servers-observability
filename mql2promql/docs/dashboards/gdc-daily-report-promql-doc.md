# MQL to PromQL Conversion Guide - GDC Daily Report 

This document explains the proposed translations to Prometheus Query Language (PromQL) of the `dashboards/gdc-daily-report.json` dashboard and the Testing Results

## `dashboards/gdc-daily-report.json`

This section details the conversion of widgets from the "GDC - Daily Report" dashboard from Monitoring Query Language (MQL) to Prometheus Query Language (PromQL). The goal was to create a dashboard with feature parity using only PromQL queries, compatible with Google Cloud's Managed Service for Prometheus.

| Group          | Input Query Title               | Input Query Type | Source Query (MQL)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | LLM Reasoning                                                                                                                                                                                                                                                                                                                                                                                                                      | LLM Output Query Type | LLM Output PromQL Query                                                                                                                                                                                                                                                                                                                            | Comments                                                                                                                                                                                             |
| :------------- | :------------------------------ | :--------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Availability   | Node Availability               | MQL              | `fetch k8s_node \| metric 'kubernetes.io/anthos/node/cpu/core_usage_time' \| ... \| join \| ... \| condition val() > 0 \| group_by [resource.node_name], [value_has_cpu: aggregate(val(0))]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | The MQL query determines node availability by checking if there is any CPU usage. The PromQL equivalent uses `rate()` to check for CPU activity and sums the boolean result (1 if active, 0 if not) for each node. The `> 0` at the end is for the condition, but the `sum by` counts nodes. A more direct PromQL translation to count nodes with CPU activity is to count the series with a rate greater than 0. | PromQL                | `sum by (node_name) (rate(kubernetes_io:anthos_node_cpu_core_usage_time{monitored_resource="k8s_node",${cluster_name},cluster_name=~"${market.value}.*"}[5m])) > 0`                                                                                                                                                                        | The PromQL query identifies nodes with active CPU usage.                                                                                                                                           |
| Availability   | VM Availability                 | MQL              | `fetch k8s_container \| metric 'kubernetes.io/anthos/kubevirt_vmi_network_transmit_bytes_total' \| ... \| align rate(2m) \| ... \| condition value_kubevirt_vmi_network_transmit_bytes_total > 0 \| val(0)`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | The MQL query counts VMs with network transmit activity. The PromQL version calculates the transmission rate for each VM and counts how many have a rate greater than 0. The `sum by > 0` produces a boolean, and `count by` counts the true results.                                                                                                    | PromQL                | `count by (kubernetes_vmi_label_kubevirt_vm) ( sum by (kubernetes_vmi_label_kubevirt_vm) ( rate(kubernetes_io:anthos_kubevirt_vmi_network_transmit_bytes_total{monitored_resource="k8s_container",${cluster_name},cluster_name=~"${market.value}.*"}[2m]) ) > 0 )`                                                                          | This PromQL query accurately counts the number of VMs with active network transmission.                                                                                                              |
| Performance    | Node CPU Utilization            | MQL              | `fetch k8s_node \| metric 'kubernetes.io/anthos/node/cpu/allocatable_utilization' \| ... \| group_by 1m, [mean(...)] \| scale '%'`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | The MQL query calculates the mean CPU utilization for each node. The PromQL equivalent uses `avg_over_time` to smooth the gauge metric and `avg by (node_name)` to group the results per node, multiplying by 100 to convert to a percentage.                                                                                                           | PromQL                | `avg by (node_name) (avg_over_time(kubernetes_io:anthos_node_cpu_allocatable_utilization{monitored_resource="k8s_node",${cluster_name},cluster_name=~"${market.value}.*"}[1m])) * 100`                                                                                                                                     | Provides the average CPU utilization percentage for each node.                                                                                                                                     |
| Performance    | Node Memory Utilization         | MQL              | `fetch k8s_node \| metric 'kubernetes.io/anthos/node/memory/allocatable_utilization' \| ... \| group_by [resource.node_name], ... \| scale '%'`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Similar to Node CPU Utilization, this calculates the mean memory utilization per node. The PromQL uses `avg_over_time` and `avg by (node_name)`, multiplying by 100.                                                                                                                                                                          | PromQL                | `avg by (node_name) (avg_over_time(kubernetes_io:anthos_node_memory_allocatable_utilization{monitored_resource="k8s_node",${cluster_name},cluster_name=~"${market.value}.*"}[1m])) * 100`                                                                                                                                  | Provides the average memory utilization percentage for each node.                                                                                                                                  |
| Performance    | Node Received Bytes             | MQL              | `fetch k8s_node \| metric 'kubernetes.io/anthos/node/network/received_bytes_count' \| ... \| align rate(1m)`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | The MQL `align rate(1m)` is directly translated to the PromQL `rate(metric[1m])` function, summed per node. The `unitOverride: "By/s"` was added to the dashboard JSON to ensure proper unit scaling in the UI.                                                                                                                                      | PromQL                | `sum by (node_name) (rate(kubernetes_io:anthos_node_network_received_bytes_count{monitored_resource="k8s_node",${cluster_name},cluster_name=~"${market.value}.*",interface=~"enp81s0f.*"}[1m]))`                                                                                                                                   | Calculates the rate of bytes received per node.                                                                                                                                                      |
| Performance    | Node Sent Bytes                 | MQL              | `fetch k8s_node \| metric 'kubernetes.io/anthos/node/network/sent_bytes_count' \| ... \| align rate(1m)`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Similar to Node Received Bytes, using `rate()` in PromQL and `unitOverride` in the JSON.                                                                                                                                                                                                                                          | PromQL                | `sum by (node_name) (rate(kubernetes_io:anthos_node_network_sent_bytes_count{monitored_resource="k8s_node",${cluster_name},cluster_name=~"${market.value}.*",interface=~"enp81s0f.*"}[1m]))`                                                                                                                                     | Calculates the rate of bytes sent per node.                                                                                                                                                          |
| Performance    | VM CPU Utilization              | MQL              | `fetch k8s_container \| metric 'kubernetes.io/anthos/container/cpu/request_utilization' \| ... \| filter pod_name=~"(virt-launcher).*", container_name="compute" \| group_by [resource.pod_name], ...`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Calculates the average CPU request utilization for each VM pod. PromQL uses `avg_over_time` and `avg by (pod_name)` with appropriate label filters.                                                                                                                                                                                     | PromQL                | `avg by (pod_name) (avg_over_time(kubernetes_io:anthos_container_cpu_request_utilization{monitored_resource="k8s_container",${cluster_name},cluster_name=~"${market.value}.*",pod_name=~"(virt-launcher).*\",container_name="compute"}[1m])) * 100`                                                                                | Provides the average CPU request utilization percentage for each VM.                                                                                                                                 |
| Performance    | VM Received Bytes (Per Interface) | MQL              | `fetch k8s_container \| metric 'kubernetes.io/anthos/kubevirt_vmi_network_receive_bytes_total' \| align rate(1m)`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | MQL `align rate(1m)` translates to PromQL `rate(metric[1m])`, summed by VM label and interface. Includes `unitOverride` in the JSON.                                                                                                                                                                                                  | PromQL                | `sum by (kubernetes_vmi_label_kubevirt_vm, interface) (rate(kubernetes_io:anthos_kubevirt_vmi_network_receive_bytes_total{monitored_resource="k8s_container",${cluster_name},cluster_name=~"${market.value}.*"}[1m]))`                                                                                                              | Calculates the rate of bytes received per VM per interface.                                                                                                                                        |
| Performance    | VM Sent Bytes (Per Interface)   | MQL              | `fetch k8s_container \| metric 'kubernetes.io/anthos/kubevirt_vmi_network_transmit_bytes_total' \| align rate(1m)`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Similar to VM Received Bytes, using `rate()` in PromQL and `unitOverride` in the JSON.                                                                                                                                                                                                                                           | PromQL                | `sum by (kubernetes_vmi_label_kubevirt_vm, interface) (rate(kubernetes_io:anthos_kubevirt_vmi_network_transmit_bytes_total{monitored_resource="k8s_container",${cluster_name},cluster_name=~"${market.value}.*"}[1m]))`                                                                                                             | Calculates the rate of bytes sent per VM per interface.                                                                                                                                          |

---

#### Reasoning for Conversion Choices:

1.  **Metric Name Conversion:** MQL metric names like `kubernetes.io/anthos/xxx` are converted to PromQL format by replacing the first `/` with `:` and other special characters (`.` , `/`) with `_`. For example, `kubernetes.io/anthos/node/cpu/core_usage_time` becomes `kubernetes_io:anthos_node_cpu_core_usage_time`.
2.  **Filters:** MQL `filter` operations on resource or metric labels are translated into PromQL label matchers within curly braces `{...}`. Template variables like `${cluster_name}` are preserved.
3.  **Aligners & Aggregation:**
    *   MQL `align rate(W)` translates to PromQL `rate(metric[W])`.
    *   MQL `group_by` operations with aggregations like `mean` are translated to PromQL aggregation functions (`avg`, `sum`, `count`) with `by (label)` clauses.
    *   For gauge metrics, `avg_over_time(metric[W])` is used in PromQL to get a smoothed average over a window, similar to MQL's `group_by W, [mean(...)] | every W`.
4.  **Monitored Resource:** The `monitored_resource` label is added in PromQL queries (e.g., `monitored_resource="k8s_node"`) when the metric can be associated with multiple resource types, to ensure a unique match, as per best practices for Google Cloud's Managed Service for Prometheus.
5.  **Unit Scaling:** For byte rate metrics, the raw PromQL result is in bytes/second. To match the MQL dashboard's scaled units (e.g., MiB/s), the `unitOverride: "By/s"` property was added to the `timeSeriesQuery` object within the dashboard JSON definition for the relevant widgets. This instructs the frontend to handle the unit scaling.

#### Final Comparison Summary:

The conversion process involved several iterations to ensure accuracy. Key adjustments included:

*   Correcting the "VM Availability" query to count VMs rather than summing rates.
*   Adding `avg by (node_name)` to Node CPU/Memory utilization queries to ensure per-node aggregation.
*   Adding `unitOverride` to network throughput widgets to fix unit scaling.

The final PromQL queries and dashboard configuration now provide a close match to the original MQL-based dashboard in terms of data representation, grouping, and visual scaling.